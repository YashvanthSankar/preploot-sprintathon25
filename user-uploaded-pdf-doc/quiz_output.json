[
  {
    "question": "Which of the following is NOT a characteristic of a proper algorithm?",
    "options": [
      "Correctness",
      "Deterministic",
      "Finite",
      "Complex"
    ],
    "answer": "Complex",
    "difficulty": "easy",
    "explanation": "A proper algorithm should be simple and communicable, not complex."
  },
  {
    "question": "Which of the following is NOT a major factor determining program performance?",
    "options": [
      "Algorithm and Data Structures",
      "Hardware",
      "Programming Language",
      "Compiler"
    ],
    "answer": "Hardware",
    "difficulty": "medium",
    "explanation": "Algorithm and Data Structures are major factors; Hardware, Programming Language, and Compiler are platform dependent."
  },
  {
    "question": "What is the primary question asked in Algorithm Analysis?",
    "options": [
      "How many lines of code does it have?",
      "How fast is my algorithm as a function of input size?",
      "How much memory does it use?",
      "How much power does it consume?"
    ],
    "answer": "How fast is my algorithm as a function of input size?",
    "difficulty": "medium",
    "explanation": "Algorithm analysis focuses on understanding how the execution time of an algorithm scales with the input size."
  },
  {
    "question": "What does Step-Count Analysis primarily involve?",
    "options": [
      "Measuring the exact execution time of an algorithm.",
      "Counting the number of steps/operations an algorithm takes.",
      "Analyzing the memory usage of an algorithm.",
      "Comparing the algorithm to other algorithms."
    ],
    "answer": "Counting the number of steps/operations an algorithm takes.",
    "difficulty": "medium",
    "explanation": "Step-count analysis focuses on quantifying the operations performed as a function of input size."
  },
  {
    "question": "What is the purpose of Sensitivity Analysis?",
    "options": [
      "To measure the exact running time of an algorithm.",
      "To determine how sensitive the running time is to the input size.",
      "To model memory delays.",
      "To ignore lower-order terms."
    ],
    "answer": "To determine how sensitive the running time is to the input size.",
    "difficulty": "medium",
    "explanation": "Sensitivity analysis investigates how the execution time changes as the input size increases."
  },
  {
    "question": "If lim n→∞ f(n)/g(n) = ∞, what is the relationship between f(n) and g(n)?",
    "options": [
      "f(n) ∈ o(g(n))",
      "f(n) ∈ Θ(g(n))",
      "f(n) ∈ ω(g(n))",
      "f(n) ∈ O(g(n))"
    ],
    "answer": "f(n) ∈ ω(g(n))",
    "difficulty": "hard",
    "explanation": "If the limit is infinity, f(n) grows strictly faster than g(n), indicating little-omega notation."
  },
  {
    "question": "What is the purpose of recurrence relations in algorithm analysis?",
    "options": [
      "To determine the exact execution time.",
      "To express the nth term with reference to previous term(s).",
      "To ignore machine specific constants.",
      "To compare to other algorithms"
    ],
    "answer": "To express the nth term with reference to previous term(s).",
    "difficulty": "medium",
    "explanation": "Recurrence relations describe the execution time of recursive algorithms in terms of calls to themselves."
  },
  {
    "question": "In the standard form of divide and conquer recurrences T(n) = aT(n/b) + f(n), what does 'a' represent?",
    "options": [
      "Branching factor",
      "Reduction factor",
      "Overhead cost",
      "Input size"
    ],
    "answer": "Branching factor",
    "difficulty": "medium",
    "explanation": "'a' indicates the number of subproblems created in each recursive step."
  },
  {
    "question": "In the context of loop invariants, what must be true before the first iteration?",
    "options": [
      "The loop must terminate.",
      "The loop invariant must be true.",
      "The loop must execute for a set number of times.",
      "The loop must take more than a set amount of time."
    ],
    "answer": "The loop invariant must be true.",
    "difficulty": "medium",
    "explanation": "The loop invariant is a condition that must hold true before the loop starts."
  },
  {
    "question": "What is the time complexity of Heapsort?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(n^2)"
    ],
    "answer": "O(n log n)",
    "difficulty": "easy",
    "explanation": "Heapsort has a time complexity of O(n log n)."
  },
  {
    "question": "What is the time complexity of the partition step in Quick Sort?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(n^2)"
    ],
    "answer": "O(n)",
    "difficulty": "medium",
    "explanation": "The partition step in quicksort, which rearranges elements, runs in linear time with respect to the number of elements."
  },
  {
    "question": "In the Greedy Method, what is the 'goal' in the optimization problem setup?",
    "options": [
      "The set of instances",
      "The set of feasible solutions",
      "The objective function",
      "Maximize or minimize"
    ],
    "answer": "Maximize or minimize",
    "difficulty": "medium",
    "explanation": "The goal specifies whether the problem is to find a solution that maximizes or minimizes the objective function."
  },
  {
    "question": "Which of the following is a characteristic of the Greedy Algorithm Strategy?",
    "options": [
      "Makes choices based on all the future consequences",
      "Makes locally optimal choices",
      "Chooses a random solution.",
      "Only works with small inputs."
    ],
    "answer": "Makes locally optimal choices",
    "difficulty": "medium",
    "explanation": "Greedy algorithms make the choice that seems best at the current moment, without considering the overall effect."
  },
  {
    "question": "Which is the correct approach for the Coin Change Problem to work?",
    "options": [
      "Take the smallest coin possible.",
      "Take the largest coin.",
      "Alternate between largest and smallest coins.",
      "Take the coins at random."
    ],
    "answer": "Take the largest coin.",
    "difficulty": "easy",
    "explanation": "The classic coin change problem uses the greedy method by taking the largest coin possible."
  },
  {
    "question": "For which of the following does the greedy strategy provide an optimal solution?",
    "options": [
      "Coin Change Problem (with all coin values).",
      "Container Loading Problem.",
      "Job Scheduling with Deadlines.",
      "All of the above."
    ],
    "answer": "All of the above.",
    "difficulty": "hard",
    "explanation": "Greedy method works optimally for those 3 problems."
  }
]